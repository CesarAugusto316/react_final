{
  // Place your snippets for typescript here. Each snippet is defined under a
  // snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the
  // body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label},
  // ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  // "Print to console": {
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
  "create redux typed hooks": {
    "prefix": "rxtypedhooks",
    "body": [
      "import { useDispatch, useSelector } from 'react-redux';",
      "import type { TypedUseSelectorHook } from 'react-redux';",
      "import type { RootState, AppDispatch } from './store';",
      "",
      "",
      "// Use throughout your app instead of plain `useDispatch` and `useSelector`",
      "export const useTypedDispatch: () => AppDispatch = useDispatch;",
      "export const useTypedSelector: TypedUseSelectorHook<RootState> = useSelector;"
    ],
    "description": "create redux typed hooks for typescript"
  },
  "change redux slice based on another slice": {
    "prefix": "rxdependentslices",
    "body": [
      "import { createSlice, PayloadAction } from '@reduxjs/toolkit';",
      "import { RootState } from '../redux/store';",
      "import { anotherSlice } from './anotherSlice';",
      "",
      "",
      "type ${2:${TM_FILENAME_BASE}}InitialState = {",
      "  numOf${2:${TM_FILENAME_BASE}}: number;",
      "};",
      "",
      "export const ${TM_FILENAME_BASE} = createSlice({",
      "  name: '${1:${TM_FILENAME_BASE}}',",
      "  initialState: {",
      "    numOf${2:${TM_FILENAME_BASE}}: 10,",
      "  } as ${2:${TM_FILENAME_BASE}}InitialState,",
      "",
      "  reducers: {",
      "    ordered: (state: ${2:${TM_FILENAME_BASE}}InitialState) => {",
      "      state.numOf${2:${TM_FILENAME_BASE}}--;",
      "    },",
      "    restocked: (state: ${2:${TM_FILENAME_BASE}}InitialState, action: PayloadAction<number>) => {",
      "      state.numOf${2:${TM_FILENAME_BASE}} += action.payload;",
      "    },",
      "  },",
      "",
      "  /**",
      "   * @description changes this slice's state based on another slice's",
      "   * state changes.",
      "   */",
      "  extraReducers: (builder) => {",
      "    builder.addCase(anotherSlice, (state) => {",
      "      state.numOf${2:${TM_FILENAME_BASE}}--;",
      "    });",
      "  },",
      "});",
      "",
      "export const { ordered, restocked } = ${TM_FILENAME_BASE}.actions;",
      "export const select${2:${TM_FILENAME_BASE}} = (state: RootState) => state.${1:${TM_FILENAME_BASE}};"
    ],
    "description": "change redux current slice when another slice changes"
  },
  "create a redux store": {
    "prefix": "rxstore",
    "body": [
      "import { configureStore } from '@reduxjs/toolkit';",
      "/** Uncomment when using RTK QUERY */",
      "// import { setupListeners } from '@reduxjs/toolkit/dist/query';",
      "// import { someApi } from '../apis/someApi';",
      "",
      "",
      "export const store = configureStore({",
      "  reducer: {",
      "    $1",
      "    // [someApi.reducerPath]: someApi.reducer,",
      "  },",
      "",
      "  /** Uncomment when using RTK QUERY */",
      "  // // Adding the api middleware enables caching, invalidation, polling,",
      "  // // and other useful features of `rtk-query`.",
      "  // middleware: (getDefaultMiddleware) =>",
      "  //   getDefaultMiddleware().concat(someApi.middleware),",
      "});",
      "",
      "// Infer the `RootState` and `AppDispatch` types from the store itself",
      "export type RootState = ReturnType<typeof store.getState>;",
      "export type AppDispatch = typeof store.dispatch;",
      "",
      "/** Uncomment when using RTK QUERY */",
      "// // optional, but required for refetchOnFocus/refetchOnReconnect behaviors",
      "// // see `setupListeners` docs - takes an optional callback as the 2nd arg for customization",
      "// setupListeners(store.dispatch);"
    ],
    "description": "create a redux store for typescript"
  },
  "create redux async function": {
    "prefix": "rxasyncfuntion",
    "body": [
      "import axios from 'axios';",
      "",
      "",
      "//example",
      "const API_URL = 'https://jsonplaceholder.typicode.com/users';",
      "",
      "/**",
      " *",
      " * @description Async action creator without createAyncThunk,",
      " * we use action creators and a dispatcher in the current slice",
      " * to change the state.",
      " */",
      "export const fetch${1:${TM_FILENAME_BASE}} = (/* fetch${1:${TM_FILENAME_BASE}}.params */) => {",
      "  //",
      "  return async (dispatch, getState) => {",
      "    try {",
      "      dispatch(startLoading${1:${TM_FILENAME_BASE}}());",
      "",
      "      const { data } = await axios.get(API_URL);",
      "      setTimeout(() => {",
      "        dispatch(setPayload${1:${TM_FILENAME_BASE}}({ users: data }))",
      "      }, 1000)",
      "      //",
      "    } catch (error) {",
      "      console.log(error.message);",
      "    }",
      "  };",
      "};"
    ],
    "description": "creates redux async function without createAsyncThunk, it can be used in timers."
  },
  "create a redux slice": {
    "prefix": "rxslice",
    "body": [
      "import { createSlice } from '@reduxjs/toolkit'",
      "import type { PayloadAction } from '@reduxjs/toolkit'",
      "import type { RootState } from '../redux/store';",
      "",
      "",
      "export interface ${1:${TM_FILENAME_BASE}}State {",
      "  value: number",
      "}",
      "",
      "export const ${TM_FILENAME_BASE} = createSlice({",
      "  name: '${1:${TM_FILENAME_BASE}}',",
      "  initialState: {",
      "    value: 0 $4,",
      "  } as ${1:${TM_FILENAME_BASE}}State,",
      "  reducers: {",
      "    ${3:reducer}: (state: ${1:myState}State, /* action: PayloadAction<${5:typeDefinition}> */ ) => {",
      "      // Redux Toolkit allows us to write 'mutating' logic in reducers. It",
      "      // doesn't actually mutate the state because it uses the Immer library,",
      "      // which detects changes to a 'draft state' and produces a brand new",
      "      // immutable state based off those changes",
      "    },",
      "  },",
      "})",
      "",
      "// Action creators are generated for each case reducer function",
      "export const { $5 } = ${TM_FILENAME_BASE}.actions",
      "export const select${2:${TM_FILENAME_BASE}} = (state: RootState) => state.${1:${TM_FILENAME_BASE}}"
    ],
    "description": "create a redux slice for typescript"
  },
  "create redux asyncThunk slice": {
    "prefix": "rxthunkslice",
    "body": [
      "import axios from axios';",
      "import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';",
      "import { RootState } from '../redux/store';",
      "",
      "",
      "interface ${2:${TM_FILENAME_BASE}} {",
      "  id: number;",
      "  name: string;",
      "}",
      "",
      "interface ${2:${TM_FILENAME_BASE}}InitialState {",
      "  loading: boolean;",
      "  users: ${2:${TM_FILENAME_BASE}}[];",
      "  error: string;",
      "}",
      "",
      "const API_URL = 'https://jsonplaceholder.typicode.com/users';",
      "",
      "/**",
      " * Generates pending, fulfilled and rejected action types and",
      " * action-creator to pass in to dispatch",
      " */",
      "export const fetch${2:${TM_FILENAME_BASE}} = createAsyncThunk(",
      "  '${1:${TM_FILENAME_BASE}}/fetch${2:${TM_FILENAME_BASE}}',",
      "  async (/* fetch${2:${TM_FILENAME_BASE}}.Params */) => {",
      "    const { data } = await axios.get(API_URL);",
      "    return data; // action: {payload: data}",
      "  }",
      ");",
      "",
      "export const ${TM_FILENAME_BASE} = createSlice({",
      "  name: '${1:${TM_FILENAME_BASE}}',",
      "  initialState: {",
      "    loading: false,",
      "    users: [],",
      "    error: '',",
      "  } as ${2:${TM_FILENAME_BASE}}InitialState,",
      "  reducers: {},",
      "  extraReducers: (builder) => {",
      "    builder.addCase(fetch${2:${TM_FILENAME_BASE}}.pending, (state) => {",
      "      state.loading = true;",
      "    });",
      "    builder.addCase(",
      "      fetch${2:${TM_FILENAME_BASE}}.fulfilled,",
      "      (state, action: PayloadAction<${2:${TM_FILENAME_BASE}}[]>) => {",
      "        state.loading = false;",
      "        state.users = action.payload;",
      "        state.error = '';",
      "      }",
      "    );",
      "    builder.addCase(fetch${2:${TM_FILENAME_BASE}}.rejected, (state, action) => {",
      "      state.loading = false;",
      "      state.users = [];",
      "      state.error = action.error.message || 'Something went wrong';",
      "    });",
      "  },",
      "});",
      "",
      "export const select${2:${TM_FILENAME_BASE}} = (state: RootState) => state.${1:${TM_FILENAME_BASE}};"
    ],
    "description": "creates a redux asynchronous thunk slice for typescript"
  },
  "create rtk query Api": {
    "prefix": "rtkapi",
    "body": [
      "import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';",
      "import type { SomeType, AnotherType } from './types';",
      "",
      "",
      "const API_URL = 'https://jsonplaceholder.typicode.com/';",
      "",
      "// Define a service using a base URL and expected endpoints",
      "export const ${TM_FILENAME_BASE} = createApi({",
      "  reducerPath: '${TM_FILENAME_BASE}', // name for our reducer, slice and action creator",
      "",
      "  /** @fetchBaseQuery wrapper around fecth API. */",
      "  baseQuery: fetchBaseQuery({",
      "    baseUrl: API_URL,",
      "    // headers: if we wish to auth.",
      "    // method: 'get | post | patch | etc'",
      "    // credentials",
      "  }),",
      "",
      "  // by default, data will remain in the cache for 60 seconds after",
      "  // the subscriber reference count hits zero.",
      "  // global configuration for the api",
      "  keepUnusedDataFor: 180,",
      "",
      "  /**",
      "   * @description defines function that fetches data from",
      "   * a url's endpoint.",
      "   */",
      "  endpoints: (builder) => ({",
      "    get${2:${TM_FILENAME_BASE}}: builder.query<SomeType, string>({",
      "      query: (/* @params */) => '/${1:${TM_FILENAME_BASE}}', // baseUrl + '/${1:${TM_FILENAME_BASE}}' + @params",
      "      // configuration for an individual endpoint, overriding the api setting",
      "      keepUnusedDataFor: 60,",
      "    }),",
      "",
      "    get${2:${TM_FILENAME_BASE}}ByID: builder.query<AnotherType, string>({",
      "      query: (id) => '/${1:${TM_FILENAME_BASE}}/' + id,",
      "    }),",
      "  }),",
      "});",
      "",
      "// Custom hooks for usage in functional components, which are",
      "// auto-generated based on the defined endpoints",
      "export const { useGet${2:${TM_FILENAME_BASE}}Query, useGet${2:${TM_FILENAME_BASE}}ByIDQuery } = ${TM_FILENAME_BASE};"
    ],
    "description": "create rtk query Api and endpoints Hooks for requesting data over HTTP."
  }
}